import { getDestinyManifest } from "bungie-api-ts/destiny2";
import { allTableNames } from "./generated-data.js";
import { getDestinyManifestComponent } from "bungie-api-ts/destiny2";
export * from "./generated-funcs.js";
export { emptyTables, defLanguages } from "./generated-data.js";
export let isVerbose = false;
/**
 * run this if you love console logs
 */
export function verbose() {
    isVerbose = true;
}
/**
 * this makes requests with the bungie-api-ts functions and using the api key header
 */
let httpClient = generateHttpClient(fetch);
/**
 * it may work without, but you should add an api key,
 * especially if you are in a browser and need proper CORS headers
 */
export function setApiKey(apiKey) {
    httpClient = generateHttpClient(fetch, apiKey);
}
/**
 * stores the language we'll try to fetch from API or cache
 */
export let language = "en";
/**
 * sets the language of the manifest to download.
 * note this doesn't re-trigger a download. you'll need to load() again.
 */
export function setLanguage(lang) {
    language = lang;
}
let includedTables = new Set();
let excludedTables = new Set();
/**
 * add tables which should be downloaded and available for lookups.
 * if unset, we download all tables except for excludeTables.
 *
 * use only this or excludeTables, not both.
 */
export function includeTables(tables) {
    if (excludedTables.size)
        throw "cannot use both includeTables and excludeTables";
    for (const t of tables)
        includedTables.add(t);
}
/**
 * if set, all available tables will be downloaded and available
 * for lookups, except those specified here.
 *
 * this completely overrides includeTables.
 * use only this or includeTables, not both.
 */
export function excludeTables(tables) {
    if (includedTables.size)
        throw "cannot use both includeTables and excludeTables";
    for (const t of tables)
        excludedTables.add(t);
}
let manifestResponseCache;
let cacheTimestamp = 0;
async function fetchManifestMetadata() {
    const now = Date.now();
    // ignore the cache after a minute
    if (manifestResponseCache && now - cacheTimestamp < 60000)
        return manifestResponseCache;
    const newManifestResponse = (await getDestinyManifest(httpClient)).Response;
    manifestResponseCache = newManifestResponse;
    cacheTimestamp = now;
    return newManifestResponse;
}
/**
 * you could access this directly,
 * if you're no fun and don't like my convenience get() and getAll() functions
 *
 * it's the big old object with all manifest data in it
 */
export let allManifest;
export function setManifest(manifest) {
    allManifest = manifest;
}
/**
 * the manifest version currently loaded in memory.
 * the version that you'll get information from if you `getDef()` an entry.
 *
 * this is in the form of `${manifestMetadata.version}__${language}`
 * (or the string "nothing loaded yet")
 */
export let loadedVersion = "nothing loaded yet";
/**
 * don't use this directly.
 * `@d2api/manifest-node` and `@d2api/manifest-web` use this function.
 * why are you even in here. go use those.
 *
 * `loadDefs()` from the web or node version should automatically
 * deal with making sure we tried to get a cached version first,
 * loadedVersion is correct, etc.
 */
export async function loadManifestFromApiWithoutCheckingCache(
// a function that tries to retrieve the cached version of a table/language.
// by default, basically a noop/autofail
cacheGetter = () => undefined, forceUpdate = false) {
    const manifestMetadata = await fetchManifestMetadata();
    const apiVersion = `${manifestMetadata.version}__${language}`;
    !forceUpdate &&
        vlog(`version loaded in memory: "${loadedVersion}"
version in API: "${apiVersion}"`);
    const tablesNeeded = getNeededTables();
    const versionsMatch = loadedVersion === apiVersion;
    let needsUpdate = forceUpdate || !allManifest || !versionsMatch;
    if (!needsUpdate) {
        if (tablesNeeded.some((t) => !(t in allManifest))) {
            vlog("but some requested tables aren't loaded yet");
            needsUpdate = true;
        }
    }
    // we're done if everything is fine
    if (!needsUpdate) {
        vlog("loaded manifest is already up to date");
        return;
    }
    vlog(`loading ${tablesNeeded.length === allTableNames.length
        ? "the entire manifest"
        : `${tablesNeeded.length} requested tables`}`);
    const newManifest = {};
    let cacheHits = 0;
    let reusedExisting = 0;
    let downloaded = 0;
    await Promise.all(tablesNeeded.map(async (tableName) => {
        var _a, _b;
        let newTableData;
        // if forceUpdate, reuse nothing
        if (forceUpdate) {
            newTableData = undefined;
        }
        // if API version hasn't changed, and we already have this table loaded, use that
        else if (versionsMatch && tableName in allManifest) {
            newTableData = allManifest[tableName];
            reusedExisting++;
        }
        // otherwise, check our caching method for a copy of this version
        else {
            newTableData = await cacheGetter({
                version: manifestMetadata.version,
                tableName,
                language,
            });
            if (newTableData)
                cacheHits++;
        }
        // fall back to doing an entire table download if none of the above got us what we need
        if (!newTableData && ((_b = (_a = manifestMetadata.jsonWorldComponentContentPaths) === null || _a === void 0 ? void 0 : _a[language]) === null || _b === void 0 ? void 0 : _b[`Destiny${tableName}Definition`])) {
            newTableData = await getDestinyManifestComponent(httpClient, {
                // remove this any when getDestinyManifestComponent is aware of invitemlite
                tableName: `Destiny${tableName}Definition`,
                language,
                destinyManifest: manifestMetadata,
            });
            downloaded++;
        }
        if (newTableData)
            newManifest[tableName] = newTableData;
    }));
    vlog(`${downloaded} components downloaded / ${cacheHits} loaded from cache / ${reusedExisting} already in memory`);
    allManifest = newManifest;
    loadedVersion = apiVersion;
}
export function getDef(componentName, hash) {
    if (!hash)
        return;
    if (!allManifest)
        throw "manifest accessed before being loaded";
    if (!(componentName in allManifest))
        throw `table [${componentName}] isn't available. did you exclude it with excludeTables, or forget to load it with includeTables?`;
    // this used to work in types and now it doesn't. frustrating.
    return allManifest[componentName][hash];
}
/**
 * returns an array of all the values in a manifest component,
 * such as DestinyActivityDefinition
 */
export function getAllDefs(componentName) {
    if (!allManifest)
        throw "manifest accessed before being loaded";
    if (!(componentName in allManifest))
        throw `table [${componentName}] isn't available. did you load it?`;
    return Object.values(allManifest[componentName]);
}
/** returns a manifest component (a set of definitions keyed by hash number) */
export function getComponent(componentName) {
    if (!allManifest)
        throw "manifest accessed before being loaded";
    if (!(componentName in allManifest))
        throw `table [${componentName}] isn't available. did you load it?`;
    return allManifest[componentName];
}
function generateHttpClient(fetchLike, apiKey) {
    return async function httpClient(config) {
        const body = config.body && JSON.stringify(config.body);
        const headers = {};
        if (apiKey && config.url.includes("/Platform/"))
            headers["X-API-Key"] = apiKey;
        const res = await fetchLike(config.url, {
            ...config,
            body,
            headers,
        });
        const fetched = await res.json();
        if ((fetched === null || fetched === void 0 ? void 0 : fetched.ErrorCode) !== undefined && (fetched === null || fetched === void 0 ? void 0 : fetched.ErrorCode) !== 1) {
            throw new Error(Object.entries(fetched)
                .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
                .join("\n"));
        }
        else
            return fetched;
    };
}
export function vlog(str) {
    isVerbose && console.log(str);
}
/**
 * compares between `.` or `-` separated manifest version numbers
 *
 * feed this into a sort() to get highest version first
 */
export function compareVersionNumbers(a, b) {
    const a_ = a.split(/\D+/).filter(Boolean);
    const b_ = b.split(/\D+/).filter(Boolean);
    for (var i = 0; i < a_.length; i++) {
        // sort highest to front
        let comparison = Number(b_[i]) - Number(a_[i]);
        if (comparison)
            return comparison;
    }
    return 0;
}
export function getNeededTables() {
    return excludedTables.size
        ? allTableNames.filter((tn) => !excludedTables.has(tn))
        : includedTables.size
            ? Array.from(includedTables)
            : allTableNames;
}
