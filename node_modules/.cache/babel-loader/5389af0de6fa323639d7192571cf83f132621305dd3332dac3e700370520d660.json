{"ast":null,"code":"import { getDestinyManifest } from \"bungie-api-ts/destiny2\";\nimport { allTableNames } from \"./generated-data.js\";\nimport { getDestinyManifestComponent } from \"bungie-api-ts/destiny2\";\nexport * from \"./generated-funcs.js\";\nexport { emptyTables, defLanguages } from \"./generated-data.js\";\nexport let isVerbose = false;\n/**\r\n * run this if you love console logs\r\n */\nexport function verbose() {\n  isVerbose = true;\n}\n/**\r\n * this makes requests with the bungie-api-ts functions and using the api key header\r\n */\nlet httpClient = generateHttpClient(fetch);\n/**\r\n * it may work without, but you should add an api key,\r\n * especially if you are in a browser and need proper CORS headers\r\n */\nexport function setApiKey(apiKey) {\n  httpClient = generateHttpClient(fetch, apiKey);\n}\n/**\r\n * stores the language we'll try to fetch from API or cache\r\n */\nexport let language = \"en\";\n/**\r\n * sets the language of the manifest to download.\r\n * note this doesn't re-trigger a download. you'll need to load() again.\r\n */\nexport function setLanguage(lang) {\n  language = lang;\n}\nlet includedTables = new Set();\nlet excludedTables = new Set();\n/**\r\n * add tables which should be downloaded and available for lookups.\r\n * if unset, we download all tables except for excludeTables.\r\n *\r\n * use only this or excludeTables, not both.\r\n */\nexport function includeTables(tables) {\n  if (excludedTables.size) throw \"cannot use both includeTables and excludeTables\";\n  for (const t of tables) includedTables.add(t);\n}\n/**\r\n * if set, all available tables will be downloaded and available\r\n * for lookups, except those specified here.\r\n *\r\n * this completely overrides includeTables.\r\n * use only this or includeTables, not both.\r\n */\nexport function excludeTables(tables) {\n  if (includedTables.size) throw \"cannot use both includeTables and excludeTables\";\n  for (const t of tables) excludedTables.add(t);\n}\nlet manifestResponseCache;\nlet cacheTimestamp = 0;\nasync function fetchManifestMetadata() {\n  const now = Date.now();\n  // ignore the cache after a minute\n  if (manifestResponseCache && now - cacheTimestamp < 60000) return manifestResponseCache;\n  const newManifestResponse = (await getDestinyManifest(httpClient)).Response;\n  manifestResponseCache = newManifestResponse;\n  cacheTimestamp = now;\n  return newManifestResponse;\n}\n/**\r\n * you could access this directly,\r\n * if you're no fun and don't like my convenience get() and getAll() functions\r\n *\r\n * it's the big old object with all manifest data in it\r\n */\nexport let allManifest;\nexport function setManifest(manifest) {\n  allManifest = manifest;\n}\n/**\r\n * the manifest version currently loaded in memory.\r\n * the version that you'll get information from if you `getDef()` an entry.\r\n *\r\n * this is in the form of `${manifestMetadata.version}__${language}`\r\n * (or the string \"nothing loaded yet\")\r\n */\nexport let loadedVersion = \"nothing loaded yet\";\n/**\r\n * don't use this directly.\r\n * `@d2api/manifest-node` and `@d2api/manifest-web` use this function.\r\n * why are you even in here. go use those.\r\n *\r\n * `loadDefs()` from the web or node version should automatically\r\n * deal with making sure we tried to get a cached version first,\r\n * loadedVersion is correct, etc.\r\n */\nexport async function loadManifestFromApiWithoutCheckingCache() {\n  let cacheGetter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => undefined;\n  let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const manifestMetadata = await fetchManifestMetadata();\n  const apiVersion = `${manifestMetadata.version}__${language}`;\n  !forceUpdate && vlog(`version loaded in memory: \"${loadedVersion}\"\nversion in API: \"${apiVersion}\"`);\n  const tablesNeeded = getNeededTables();\n  const versionsMatch = loadedVersion === apiVersion;\n  let needsUpdate = forceUpdate || !allManifest || !versionsMatch;\n  if (!needsUpdate) {\n    if (tablesNeeded.some(t => !(t in allManifest))) {\n      vlog(\"but some requested tables aren't loaded yet\");\n      needsUpdate = true;\n    }\n  }\n  // we're done if everything is fine\n  if (!needsUpdate) {\n    vlog(\"loaded manifest is already up to date\");\n    return;\n  }\n  vlog(`loading ${tablesNeeded.length === allTableNames.length ? \"the entire manifest\" : `${tablesNeeded.length} requested tables`}`);\n  const newManifest = {};\n  let cacheHits = 0;\n  let reusedExisting = 0;\n  let downloaded = 0;\n  await Promise.all(tablesNeeded.map(async tableName => {\n    var _a, _b;\n    let newTableData;\n    // if forceUpdate, reuse nothing\n    if (forceUpdate) {\n      newTableData = undefined;\n    }\n    // if API version hasn't changed, and we already have this table loaded, use that\n    else if (versionsMatch && tableName in allManifest) {\n      newTableData = allManifest[tableName];\n      reusedExisting++;\n    }\n    // otherwise, check our caching method for a copy of this version\n    else {\n      newTableData = await cacheGetter({\n        version: manifestMetadata.version,\n        tableName,\n        language\n      });\n      if (newTableData) cacheHits++;\n    }\n    // fall back to doing an entire table download if none of the above got us what we need\n    if (!newTableData && ((_b = (_a = manifestMetadata.jsonWorldComponentContentPaths) === null || _a === void 0 ? void 0 : _a[language]) === null || _b === void 0 ? void 0 : _b[`Destiny${tableName}Definition`])) {\n      newTableData = await getDestinyManifestComponent(httpClient, {\n        // remove this any when getDestinyManifestComponent is aware of invitemlite\n        tableName: `Destiny${tableName}Definition`,\n        language,\n        destinyManifest: manifestMetadata\n      });\n      downloaded++;\n    }\n    if (newTableData) newManifest[tableName] = newTableData;\n  }));\n  vlog(`${downloaded} components downloaded / ${cacheHits} loaded from cache / ${reusedExisting} already in memory`);\n  allManifest = newManifest;\n  loadedVersion = apiVersion;\n}\nexport function getDef(componentName, hash) {\n  if (!hash) return;\n  if (!allManifest) throw \"manifest accessed before being loaded\";\n  if (!(componentName in allManifest)) throw `table [${componentName}] isn't available. did you exclude it with excludeTables, or forget to load it with includeTables?`;\n  // this used to work in types and now it doesn't. frustrating.\n  return allManifest[componentName][hash];\n}\n/**\r\n * returns an array of all the values in a manifest component,\r\n * such as DestinyActivityDefinition\r\n */\nexport function getAllDefs(componentName) {\n  if (!allManifest) throw \"manifest accessed before being loaded\";\n  if (!(componentName in allManifest)) throw `table [${componentName}] isn't available. did you load it?`;\n  return Object.values(allManifest[componentName]);\n}\n/** returns a manifest component (a set of definitions keyed by hash number) */\nexport function getComponent(componentName) {\n  if (!allManifest) throw \"manifest accessed before being loaded\";\n  if (!(componentName in allManifest)) throw `table [${componentName}] isn't available. did you load it?`;\n  return allManifest[componentName];\n}\nfunction generateHttpClient(fetchLike, apiKey) {\n  return async function httpClient(config) {\n    const body = config.body && JSON.stringify(config.body);\n    const headers = {};\n    if (apiKey && config.url.includes(\"/Platform/\")) headers[\"X-API-Key\"] = apiKey;\n    const res = await fetchLike(config.url, {\n      ...config,\n      body,\n      headers\n    });\n    const fetched = await res.json();\n    if ((fetched === null || fetched === void 0 ? void 0 : fetched.ErrorCode) !== undefined && (fetched === null || fetched === void 0 ? void 0 : fetched.ErrorCode) !== 1) {\n      throw new Error(Object.entries(fetched).map(_ref => {\n        let [key, value] = _ref;\n        return `${key}: ${JSON.stringify(value)}`;\n      }).join(\"\\n\"));\n    } else return fetched;\n  };\n}\nexport function vlog(str) {\n  isVerbose && console.log(str);\n}\n/**\r\n * compares between `.` or `-` separated manifest version numbers\r\n *\r\n * feed this into a sort() to get highest version first\r\n */\nexport function compareVersionNumbers(a, b) {\n  const a_ = a.split(/\\D+/).filter(Boolean);\n  const b_ = b.split(/\\D+/).filter(Boolean);\n  for (var i = 0; i < a_.length; i++) {\n    // sort highest to front\n    let comparison = Number(b_[i]) - Number(a_[i]);\n    if (comparison) return comparison;\n  }\n  return 0;\n}\nexport function getNeededTables() {\n  return excludedTables.size ? allTableNames.filter(tn => !excludedTables.has(tn)) : includedTables.size ? Array.from(includedTables) : allTableNames;\n}","map":{"version":3,"names":["getDestinyManifest","allTableNames","getDestinyManifestComponent","emptyTables","defLanguages","isVerbose","verbose","httpClient","generateHttpClient","fetch","setApiKey","apiKey","language","setLanguage","lang","includedTables","Set","excludedTables","includeTables","tables","size","t","add","excludeTables","manifestResponseCache","cacheTimestamp","fetchManifestMetadata","now","Date","newManifestResponse","Response","allManifest","setManifest","manifest","loadedVersion","loadManifestFromApiWithoutCheckingCache","cacheGetter","arguments","length","undefined","forceUpdate","manifestMetadata","apiVersion","version","vlog","tablesNeeded","getNeededTables","versionsMatch","needsUpdate","some","newManifest","cacheHits","reusedExisting","downloaded","Promise","all","map","tableName","_a","_b","newTableData","jsonWorldComponentContentPaths","destinyManifest","getDef","componentName","hash","getAllDefs","Object","values","getComponent","fetchLike","config","body","JSON","stringify","headers","url","includes","res","fetched","json","ErrorCode","Error","entries","_ref","key","value","join","str","console","log","compareVersionNumbers","a","b","a_","split","filter","Boolean","b_","i","comparison","Number","tn","has","Array","from"],"sources":["C:/Users/jorla/Documents/d2rotations/my-app/node_modules/@d2api/manifest/index.js"],"sourcesContent":["import { getDestinyManifest } from \"bungie-api-ts/destiny2\";\r\nimport { allTableNames } from \"./generated-data.js\";\r\nimport { getDestinyManifestComponent } from \"bungie-api-ts/destiny2\";\r\nexport * from \"./generated-funcs.js\";\r\nexport { emptyTables, defLanguages } from \"./generated-data.js\";\r\nexport let isVerbose = false;\r\n/**\r\n * run this if you love console logs\r\n */\r\nexport function verbose() {\r\n    isVerbose = true;\r\n}\r\n/**\r\n * this makes requests with the bungie-api-ts functions and using the api key header\r\n */\r\nlet httpClient = generateHttpClient(fetch);\r\n/**\r\n * it may work without, but you should add an api key,\r\n * especially if you are in a browser and need proper CORS headers\r\n */\r\nexport function setApiKey(apiKey) {\r\n    httpClient = generateHttpClient(fetch, apiKey);\r\n}\r\n/**\r\n * stores the language we'll try to fetch from API or cache\r\n */\r\nexport let language = \"en\";\r\n/**\r\n * sets the language of the manifest to download.\r\n * note this doesn't re-trigger a download. you'll need to load() again.\r\n */\r\nexport function setLanguage(lang) {\r\n    language = lang;\r\n}\r\nlet includedTables = new Set();\r\nlet excludedTables = new Set();\r\n/**\r\n * add tables which should be downloaded and available for lookups.\r\n * if unset, we download all tables except for excludeTables.\r\n *\r\n * use only this or excludeTables, not both.\r\n */\r\nexport function includeTables(tables) {\r\n    if (excludedTables.size)\r\n        throw \"cannot use both includeTables and excludeTables\";\r\n    for (const t of tables)\r\n        includedTables.add(t);\r\n}\r\n/**\r\n * if set, all available tables will be downloaded and available\r\n * for lookups, except those specified here.\r\n *\r\n * this completely overrides includeTables.\r\n * use only this or includeTables, not both.\r\n */\r\nexport function excludeTables(tables) {\r\n    if (includedTables.size)\r\n        throw \"cannot use both includeTables and excludeTables\";\r\n    for (const t of tables)\r\n        excludedTables.add(t);\r\n}\r\nlet manifestResponseCache;\r\nlet cacheTimestamp = 0;\r\nasync function fetchManifestMetadata() {\r\n    const now = Date.now();\r\n    // ignore the cache after a minute\r\n    if (manifestResponseCache && now - cacheTimestamp < 60000)\r\n        return manifestResponseCache;\r\n    const newManifestResponse = (await getDestinyManifest(httpClient)).Response;\r\n    manifestResponseCache = newManifestResponse;\r\n    cacheTimestamp = now;\r\n    return newManifestResponse;\r\n}\r\n/**\r\n * you could access this directly,\r\n * if you're no fun and don't like my convenience get() and getAll() functions\r\n *\r\n * it's the big old object with all manifest data in it\r\n */\r\nexport let allManifest;\r\nexport function setManifest(manifest) {\r\n    allManifest = manifest;\r\n}\r\n/**\r\n * the manifest version currently loaded in memory.\r\n * the version that you'll get information from if you `getDef()` an entry.\r\n *\r\n * this is in the form of `${manifestMetadata.version}__${language}`\r\n * (or the string \"nothing loaded yet\")\r\n */\r\nexport let loadedVersion = \"nothing loaded yet\";\r\n/**\r\n * don't use this directly.\r\n * `@d2api/manifest-node` and `@d2api/manifest-web` use this function.\r\n * why are you even in here. go use those.\r\n *\r\n * `loadDefs()` from the web or node version should automatically\r\n * deal with making sure we tried to get a cached version first,\r\n * loadedVersion is correct, etc.\r\n */\r\nexport async function loadManifestFromApiWithoutCheckingCache(\r\n// a function that tries to retrieve the cached version of a table/language.\r\n// by default, basically a noop/autofail\r\ncacheGetter = () => undefined, forceUpdate = false) {\r\n    const manifestMetadata = await fetchManifestMetadata();\r\n    const apiVersion = `${manifestMetadata.version}__${language}`;\r\n    !forceUpdate &&\r\n        vlog(`version loaded in memory: \"${loadedVersion}\"\nversion in API: \"${apiVersion}\"`);\r\n    const tablesNeeded = getNeededTables();\r\n    const versionsMatch = loadedVersion === apiVersion;\r\n    let needsUpdate = forceUpdate || !allManifest || !versionsMatch;\r\n    if (!needsUpdate) {\r\n        if (tablesNeeded.some((t) => !(t in allManifest))) {\r\n            vlog(\"but some requested tables aren't loaded yet\");\r\n            needsUpdate = true;\r\n        }\r\n    }\r\n    // we're done if everything is fine\r\n    if (!needsUpdate) {\r\n        vlog(\"loaded manifest is already up to date\");\r\n        return;\r\n    }\r\n    vlog(`loading ${tablesNeeded.length === allTableNames.length\r\n        ? \"the entire manifest\"\r\n        : `${tablesNeeded.length} requested tables`}`);\r\n    const newManifest = {};\r\n    let cacheHits = 0;\r\n    let reusedExisting = 0;\r\n    let downloaded = 0;\r\n    await Promise.all(tablesNeeded.map(async (tableName) => {\r\n        var _a, _b;\r\n        let newTableData;\r\n        // if forceUpdate, reuse nothing\r\n        if (forceUpdate) {\r\n            newTableData = undefined;\r\n        }\r\n        // if API version hasn't changed, and we already have this table loaded, use that\r\n        else if (versionsMatch && tableName in allManifest) {\r\n            newTableData = allManifest[tableName];\r\n            reusedExisting++;\r\n        }\r\n        // otherwise, check our caching method for a copy of this version\r\n        else {\r\n            newTableData = await cacheGetter({\r\n                version: manifestMetadata.version,\r\n                tableName,\r\n                language,\r\n            });\r\n            if (newTableData)\r\n                cacheHits++;\r\n        }\r\n        // fall back to doing an entire table download if none of the above got us what we need\r\n        if (!newTableData && ((_b = (_a = manifestMetadata.jsonWorldComponentContentPaths) === null || _a === void 0 ? void 0 : _a[language]) === null || _b === void 0 ? void 0 : _b[`Destiny${tableName}Definition`])) {\r\n            newTableData = await getDestinyManifestComponent(httpClient, {\r\n                // remove this any when getDestinyManifestComponent is aware of invitemlite\r\n                tableName: `Destiny${tableName}Definition`,\r\n                language,\r\n                destinyManifest: manifestMetadata,\r\n            });\r\n            downloaded++;\r\n        }\r\n        if (newTableData)\r\n            newManifest[tableName] = newTableData;\r\n    }));\r\n    vlog(`${downloaded} components downloaded / ${cacheHits} loaded from cache / ${reusedExisting} already in memory`);\r\n    allManifest = newManifest;\r\n    loadedVersion = apiVersion;\r\n}\r\nexport function getDef(componentName, hash) {\r\n    if (!hash)\r\n        return;\r\n    if (!allManifest)\r\n        throw \"manifest accessed before being loaded\";\r\n    if (!(componentName in allManifest))\r\n        throw `table [${componentName}] isn't available. did you exclude it with excludeTables, or forget to load it with includeTables?`;\r\n    // this used to work in types and now it doesn't. frustrating.\r\n    return allManifest[componentName][hash];\r\n}\r\n/**\r\n * returns an array of all the values in a manifest component,\r\n * such as DestinyActivityDefinition\r\n */\r\nexport function getAllDefs(componentName) {\r\n    if (!allManifest)\r\n        throw \"manifest accessed before being loaded\";\r\n    if (!(componentName in allManifest))\r\n        throw `table [${componentName}] isn't available. did you load it?`;\r\n    return Object.values(allManifest[componentName]);\r\n}\r\n/** returns a manifest component (a set of definitions keyed by hash number) */\r\nexport function getComponent(componentName) {\r\n    if (!allManifest)\r\n        throw \"manifest accessed before being loaded\";\r\n    if (!(componentName in allManifest))\r\n        throw `table [${componentName}] isn't available. did you load it?`;\r\n    return allManifest[componentName];\r\n}\r\nfunction generateHttpClient(fetchLike, apiKey) {\r\n    return async function httpClient(config) {\r\n        const body = config.body && JSON.stringify(config.body);\r\n        const headers = {};\r\n        if (apiKey && config.url.includes(\"/Platform/\"))\r\n            headers[\"X-API-Key\"] = apiKey;\r\n        const res = await fetchLike(config.url, {\r\n            ...config,\r\n            body,\r\n            headers,\r\n        });\r\n        const fetched = await res.json();\r\n        if ((fetched === null || fetched === void 0 ? void 0 : fetched.ErrorCode) !== undefined && (fetched === null || fetched === void 0 ? void 0 : fetched.ErrorCode) !== 1) {\r\n            throw new Error(Object.entries(fetched)\r\n                .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)\r\n                .join(\"\\n\"));\r\n        }\r\n        else\r\n            return fetched;\r\n    };\r\n}\r\nexport function vlog(str) {\r\n    isVerbose && console.log(str);\r\n}\r\n/**\r\n * compares between `.` or `-` separated manifest version numbers\r\n *\r\n * feed this into a sort() to get highest version first\r\n */\r\nexport function compareVersionNumbers(a, b) {\r\n    const a_ = a.split(/\\D+/).filter(Boolean);\r\n    const b_ = b.split(/\\D+/).filter(Boolean);\r\n    for (var i = 0; i < a_.length; i++) {\r\n        // sort highest to front\r\n        let comparison = Number(b_[i]) - Number(a_[i]);\r\n        if (comparison)\r\n            return comparison;\r\n    }\r\n    return 0;\r\n}\r\nexport function getNeededTables() {\r\n    return excludedTables.size\r\n        ? allTableNames.filter((tn) => !excludedTables.has(tn))\r\n        : includedTables.size\r\n            ? Array.from(includedTables)\r\n            : allTableNames;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}